<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-network/计算机网络-3.数据链路层">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.1">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="知识库 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="知识库 Atom Feed"><title data-rh="true">3.数据链路层（Data Link Layer） | 知识库</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://doc.xiping.work//docs/network/计算机网络-3.数据链路层"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="3.数据链路层（Data Link Layer） | 知识库"><meta data-rh="true" name="description" content="1. 基本概念"><meta data-rh="true" property="og:description" content="1. 基本概念"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://doc.xiping.work//docs/network/计算机网络-3.数据链路层"><link data-rh="true" rel="alternate" href="https://doc.xiping.work//docs/network/计算机网络-3.数据链路层" hreflang="en"><link data-rh="true" rel="alternate" href="https://doc.xiping.work//docs/network/计算机网络-3.数据链路层" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.984b0bbb.css">
<link rel="preload" href="/assets/js/runtime~main.edc8b151.js" as="script">
<link rel="preload" href="/assets/js/main.d12d1af5.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><div class="announcementBar_mb4j" style="background-color:#544a31;color:#dbdce7" role="banner"><div class="announcementBarContent_xLdY">⭐️ 如果这个网站能帮助到你，欢迎给一个star支持作者<a target="_blank" rel="noopener noreferrer" href="https://github.com/The-End-Hero/xiping-work-docusaurus">GitHub</a></div></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">知识库</b></a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">计算机基础</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/network/计算机网络-1.概述">计算机网络</a></li><li><a class="dropdown__link" href="/docs/operating-system/操作系统的基本概念">操作系统</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">数据结构与算法</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/data-structures/数据结构-1.链表">数据结构</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">前端</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/data-structures/数据结构-1.链表">数据结构</a></li></ul></div><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/The-End-Hero" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG menuWithAnnouncementBar_GW3s"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/network/计算机网络-1.概述">计算机网络</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/network/计算机网络-1.概述">1.概述</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/network/计算机网络-2.物理层">2.物理层（Physical Layer）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/network/计算机网络-3.数据链路层">3.数据链路层（Data Link Layer）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/network/计算机网络-4.网络层">4.网络层（Network Layer）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/network/计算机网络-5.传输层">5.传输层（Transport Layer）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/network/计算机网络-6.应用层">6.应用层（Application Layer）</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">计算机网络</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">3.数据链路层（Data Link Layer）</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>3.数据链路层（Data Link Layer）</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1-基本概念">1. 基本概念<a class="hash-link" href="#1-基本概念" title="Direct link to heading">​</a></h2><blockquote><p>物理层为我们传输01电信号做出了不少贡献。但是在物理层也提到，物理层自己不知道自己传输的信号有什么意义。</p><p>这就是”链接层”的功能，它规定了解读方式：多少个电信号算一组？每个信号位有何意义？</p></blockquote><p><img loading="lazy" alt="数据链路层概述" src="/assets/images/数据链路层概述-6b3c998cb1c20382b5be1696ec028e17.png" width="1089" height="383" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="链路层编址">链路层编址<a class="hash-link" href="#链路层编址" title="Direct link to heading">​</a></h3><blockquote><p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。</p><p>“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。</p><p>“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="mac地址">MAC地址<a class="hash-link" href="#mac地址" title="Direct link to heading">​</a></h3><blockquote><p>上面提到，以太网数据包的”标头”，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？</p><p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。长度为6字节，共48比特，通常用十六进制表示法，地址的每个字节被表示为一对十六进制数</p><p>每个适配器具有一个唯一的MAC地址，不随位置发生变化（就像人的身份证，而IP则像人的邮政地址）</p><p>一台路由器的每个接口都有一个ARP模块和一个适配器；</p><p>MAC地址分配：当一个公司要生产适配器时，它支付象征性的费用购买一块MAC地址空间，IEEE分配这块地址时，固定前24比特，让公司自己为每个适配器生成后24比特的唯一组合</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="arp协议地址解析协议">ARP协议(地址解析协议)<a class="hash-link" href="#arp协议地址解析协议" title="Direct link to heading">​</a></h3><blockquote><p>通过MAC，我们定义了地址。但是我们紧接着就有一个问题，那就是一块网卡怎么会知道另一块网卡的MAC地址？
答案就是ARP协议。</p><p>每个节点的ARP模块都在它的RAM中有一个ARP表，包含IP地址到MAC地址的映射关系，每个表项还包含TTL字段，表示表项过期时间（ARP表是自动创建的，如果某节点与子网断开连接，它的表项最终会从留在子网中的节点的表中删除。通常一个表项的过期时间是20分钟）</p><p>主机向其ARP模块提供一个IP地址，ARP模块返回IP地址对应的MAC地址
（注释：在OSI七层模型中，ARP属于链路层模型，所以这里也先简单介绍一下，构建知识体系）</p></blockquote><p><img loading="lazy" alt="ARP协议" src="/assets/images/ARP协议-17498776b69d8dedfa4f758584d3c437.png" width="1072" height="537" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="广播的概念">广播的概念<a class="hash-link" href="#广播的概念" title="Direct link to heading">​</a></h3><blockquote><p>其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？</p><p>回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</p></blockquote><p><img loading="lazy" alt="广播" src="/assets/images/广播-422625534ba983d2878d8d0a48d6f0aa.png" width="667" height="480" class="img_ev3q"></p><blockquote><p>上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。</p><p>有了数据包的定义、网卡的MAC地址、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-封装成帧与透明传输">2. 封装成帧与透明传输<a class="hash-link" href="#2-封装成帧与透明传输" title="Direct link to heading">​</a></h2><blockquote><p>封装成帧就是加将网络数据报加头加尾，相当于将数据打包</p><p>透明传输就是为了防止特殊的数据无法正常传输的的情况的发生，比如说在封装成帧的过程中，可能出现数据中的某些标记符与开始/结束标记符恰巧重复的情况，如果不加以处理，那么会导致无法判定帧的开始于结束。</p></blockquote><p><img loading="lazy" alt="封装成帧" src="/assets/images/封装成帧-cee18c0e0376a42c73b503537915cab3.png" width="1069" height="511" class="img_ev3q"></p><p><img loading="lazy" alt="透明传输" src="/assets/images/透明传输-6fc3a0f61e74e92855ce3e0a46c70a7f.png" width="1071" height="115" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="21-透明传输的实现方法">2.1 透明传输的实现方法<a class="hash-link" href="#21-透明传输的实现方法" title="Direct link to heading">​</a></h3><h5 class="anchor anchorWithStickyNavbar_LWe7" id="211-字符计数法">2.1.1 字符计数法<a class="hash-link" href="#211-字符计数法" title="Direct link to heading">​</a></h5><blockquote><p>就是在帧的首部做计数，这个字符记录了当前帧有多少个字符。</p><p>缺点：如果在某一个帧内，标记位后面的某个字节的数据丢失，那么会影响后面的帧</p><p>比如3 1 1 和 4 2 2 2，如果前面的帧丢失变成 3 1，那么后面的4就会被补到前面变成 3 1 4导致错误</p></blockquote><p><img loading="lazy" alt="字符计数法" src="/assets/images/字符计数法-a5fc4cad8f28c6d69afd008566fbbe82.png" width="954" height="421" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="212-字符填充法">2.1.2 字符填充法<a class="hash-link" href="#212-字符填充法" title="Direct link to heading">​</a></h4><blockquote><p>就是加头加尾分别标记开始结束，和零比特填充法（见下）对比，开始和结束的对应的字符不一样</p><p>但有可能出现数据内某段比特流数据正好与标记字段重复，从而导致误判断的情况</p></blockquote><p><img loading="lazy" alt="字符填充法1" src="/assets/images/字符填充法1-3b5b13a91df41140e912b3157d306fb3.png" width="1056" height="562" class="img_ev3q"></p><p>解决方法：添加转义字符。即对于那些与标记字符重复的数据流，在它们的前面添加一段转义字符，这样接收方在解析帧时，看到这些转义字符就不会认为那些特殊的数据当成帧的开始/结束了。</p><p><img loading="lazy" alt="字符填充法2" src="/assets/images/字符填充法2-dbee286231d0760e6d8ee9ab544cc86d.png" width="1082" height="521" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="213-零比特填充法">2.1.3 零比特填充法<a class="hash-link" href="#213-零比特填充法" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="零比特填充法" src="/assets/images/零比特填充法-28a5d049f00c92346e3fb5e6d23103e8.png" width="1058" height="530" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="214-违规编码法">2.1.4 违规编码法<a class="hash-link" href="#214-违规编码法" title="Direct link to heading">​</a></h4><p>因为曼彻斯特编码不使用高-高，低-低来表示，所以如果使用高-高，低-低来表示帧起始和终止就不会与数据冲突</p><p><img loading="lazy" alt="违规编码法" src="/assets/images/违规编码法-e4c51bb3a9b5cfa782ec0494fe4ece7d.png" width="1079" height="415" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3-差错控制">3. 差错控制<a class="hash-link" href="#3-差错控制" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="31-差错是什么从哪来的">3.1 差错是什么，从哪来的<a class="hash-link" href="#31-差错是什么从哪来的" title="Direct link to heading">​</a></h3><blockquote><p>数据链路层的差错检测的是比特的错误</p><p>需要注意的是，即使采用差错检测比特，也还是可能有未检出比特差错的情况。</p><p>因此，主要是选择一个差错检测方案，使得这种事件发生的概率很小</p></blockquote><p><img loading="lazy" alt="差错从何而来" src="/assets/images/差错从何而来-509528e4768216b2cd0951b1b07a3903.png" width="1073" height="559" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="32-为什么要在数据链路层进行差错控制">3.2 为什么要在数据链路层进行差错控制？<a class="hash-link" href="#32-为什么要在数据链路层进行差错控制" title="Direct link to heading">​</a></h3><blockquote><p>因为错误可以尽早发现，不会让一个错误的数据包发送了很长时间到达最终目的地之后才被发现，从而导致网络资源的浪费</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="33-检错编码奇偶校验码循环冗余码crc">3.3 检错编码（奇偶校验码，循环冗余码CRC）<a class="hash-link" href="#33-检错编码奇偶校验码循环冗余码crc" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="331-奇偶校验码">3.3.1 奇偶校验码<a class="hash-link" href="#331-奇偶校验码" title="Direct link to heading">​</a></h4><blockquote><p>奇偶校验：只需包含1个附加比特。</p><p>对于偶校验，选择一个值，使得所有比特中1出现偶数次。</p><p>对于奇校验，选择一个值，使得所有比特中1出现奇数次。接收方通过检测1出现的次数判断是否出现差错。如果出现偶数个比特差错，则检验不出</p><p>缺点：只能检测出1，3，5，7…等等奇位数错误，检测成功率位50%</p></blockquote><p><img loading="lazy" alt="奇偶校验码" src="/assets/images/奇偶校验码-a5e36b76fa1112cad5f6b9742c85dd95.png" width="646" height="155" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="332-循环冗余码crc">3.3.2 循环冗余码CRC<a class="hash-link" href="#332-循环冗余码crc" title="Direct link to heading">​</a></h4><blockquote><p>发送方和接收方协商一个r+1比特的生成多项式(G)，要起其最高比特位为1。发送方通过在d比特的数据后附加r比特，使得整个(d+r)比特的值能够被G整除。接收方用G去除(d+r)比特，如果余数非0，则出现差错</p></blockquote><p><img loading="lazy" alt="循环冗余码1" src="/assets/images/循环冗余码1-c635ee7f5aeb7602df9b9ae9dc6ea321.png" width="1093" height="151" class="img_ev3q"></p><p>实际例子
注释：</p><ol><li>阶数就是最高位是哪位，然后位数-1，如10011就是5-1=4,1011就是4-1=3</li><li>异或运算就是相同得0，不同得1，比如100和101做异或，结果就是001</li><li>出书和最后的余数添加到要发送的数据后面，称为帧检验序列FCS</li></ol><p><img loading="lazy" alt="循环冗余码2" src="/assets/images/循环冗余码2-3b7203c56676d238014cc842682291a9.png" width="1102" height="371" class="img_ev3q"></p><p>接收方收到数据后进行检测</p><p><img loading="lazy" alt="循环冗余码3" src="/assets/images/循环冗余码3-8e8b5cb745063cf19e0b6b9346231d6a.png" width="1071" height="470" class="img_ev3q"></p><p>需要注意的地方</p><p><img loading="lazy" alt="循环冗余码4" src="/assets/images/循环冗余码4-329c379b35c220c25b86f7a6a6ac495c.png" width="1035" height="163" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="34-纠错编码海明码">3.4 纠错编码（海明码）<a class="hash-link" href="#34-纠错编码海明码" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="第一步-确认校验码位数r">第一步 确认校验码位数r<a class="hash-link" href="#第一步-确认校验码位数r" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="海明码1" src="/assets/images/海明码1-d02fb477adabc471ed4f0a4719cb8d1d.png" width="1027" height="311" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="第二步-确定校验码和数据的位置">第二步 确定校验码和数据的位置<a class="hash-link" href="#第二步-确定校验码和数据的位置" title="Direct link to heading">​</a></h4><p>注释：
1.为什么是10为数据位？因为4位校验码+6位信息位=10位
2.校验码放到2的几次方的位置，其他的地方按顺序放已知的信息位</p><p><img loading="lazy" alt="海明码2" src="/assets/images/海明码2-8eed899f5ca7285d203e81f6559719fb.png" width="1055" height="369" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="第三步-求出校验码的值">第三步 求出校验码的值<a class="hash-link" href="#第三步-求出校验码的值" title="Direct link to heading">​</a></h4><p>注释
1.先是通过二进制位确定有几位。本题中因为最大位10的二进制是1010，所以是4为，将其标注
2.然后从p1开始看，看p1的二进制位的数值和所有信息位的对应位置的数值是否相同，然后找出来这些位
这里有点难理解，这里以p1为例辅助理解，这里找出来的就是P1,D1,D2,D4,D5</p><p><img loading="lazy" alt="海明码3" src="/assets/images/海明码3-9338901412dc6bc118078b6a8bb0a511.png" width="992" height="149" class="img_ev3q"></p><p>然后计算异或值，比如说这里D1=1,D2=0,D4=1,D5=0,就是p1要同时和0,1，0,1进行异或之后得到0，为了标识我加粗原始计算数据
举例：0和1异或得1,1和0异或得1,1和1异或得0，那么p1和0异或得0，p1就是0了
3.其他同理，按顺序计算出P2,P3,P4,然后填入表格</p><p><img loading="lazy" alt="海明码4" src="/assets/images/海明码4-6c4601902b22fe11ddb7cb4bc651633e.png" width="1036" height="576" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="第四步-检测并纠错">第四步 检测并纠错<a class="hash-link" href="#第四步-检测并纠错" title="Direct link to heading">​</a></h4><p>就是和上面一样，将所有校验位进行运算，得出的结果的值就是错误的位</p><p><img loading="lazy" alt="海明码5" src="/assets/images/海明码5-bf98d7f3b3908a056a4a8ae9605820e5.png" width="1080" height="585" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4-数据链路层的流量控制和可靠传输">4. 数据链路层的流量控制和可靠传输<a class="hash-link" href="#4-数据链路层的流量控制和可靠传输" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="41-流量控制与可靠传输">4.1 流量控制与可靠传输<a class="hash-link" href="#41-流量控制与可靠传输" title="Direct link to heading">​</a></h3><blockquote><p>流量控制是为了让传输过程中的发送速度和接受速度匹配，减少传输出错与资源浪费</p><p>可靠传输是发送端发送什么，接收端就要受到什么</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="411-停止等待协议stop-and-wait">4.1.1 停止等待协议（Stop-and-Wait）<a class="hash-link" href="#411-停止等待协议stop-and-wait" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="停等协议1" src="/assets/images/停等协议1-41617c490fefd3ea40d8ec65de671d1c.png" width="1056" height="472" class="img_ev3q"></p><blockquote><p>停止等待协议的无差错情况</p><p>注释：因为一次就一个，所以用0和1标记ack（确认序号）就行</p></blockquote><p><img loading="lazy" alt="停等协议2" src="/assets/images/停等协议2-503f9f3156c6e8613f8f2b22eb3a494f.png" width="814" height="591" class="img_ev3q"></p><blockquote><p>停止等待协议的<strong>有差错</strong>情况：</p><p>使用一个超时计时器，每发一帧就开始计时，设置时间略长于一个RTT（往返时延）。</p></blockquote><blockquote><p>发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延</p><p>RTT=传播时延x2+处理时间(有时可能直接忽略)</p></blockquote><p><img loading="lazy" alt="停等协议3" src="/assets/images/停等协议3-0f92fd3660b9391e7359c42215a83528.png" width="1109" height="560" class="img_ev3q"></p><p><img loading="lazy" alt="停等协议4" src="/assets/images/停等协议4-7b32f860fb44ddcfbeca4a27c47aaefc.png" width="856" height="549" class="img_ev3q"></p><p><img loading="lazy" alt="停等协议5" src="/assets/images/停等协议5-831888c2ac4ef67c22f6610fb26dde67.png" width="896" height="562" class="img_ev3q"></p><p>停止等待协议的特点
1.简单
2.信道利用率低。大部分时间数据都在路上，发送方很长时间闲置，资源浪费</p><p><img loading="lazy" alt="停等协议6" src="/assets/images/停等协议6-d0285dfe2a98b0e61473078b1d598686.png" width="1033" height="555" class="img_ev3q"></p><p><img loading="lazy" alt="停等协议7" src="/assets/images/停等协议7-68e98f2e631926d149a4bceda6f8545c.png" width="1032" height="511" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="412-后退n帧协议gbn">4.1.2 后退N帧协议（GBN）<a class="hash-link" href="#412-后退n帧协议gbn" title="Direct link to heading">​</a></h4><blockquote><p>因为停止等待协议太浪费时间了，所以尝试采用GBN，发送连续多个数据帧，以增大信道利用率</p><p>注释： 累计确认：就是收到一个确认帧，那么它和它之前的所有帧都默认已收到，反之，如果某个确认帧没收到，那么它和它之后的所有帧都默认丢失（即使收到了也丢掉），进行重传</p></blockquote><p><img loading="lazy" alt="GBN1" src="/assets/images/GBN1-2f1456afa15ccde9e73d33991bdea487.png" width="1024" height="452" class="img_ev3q"></p><blockquote><p>下图是一个实例</p><p>注释：此图发送2帧时丢失，所以接收方几首收到后面的帧也是直接丢弃并且发送最晚收到的有效帧1的ACK，直至2帧的超时重传机制被触发进行重传并得到ACK之后，接收方才会接受2帧以及后面的帧</p><p>如果所示，GBN的形式就像排队，接收端为所有帧“预定”了接收位置，如果接收端发送的数据因为某些原因没有接收到，即使收到了这一帧后面所有的帧，这些“排在后面的”帧也要被丢弃</p></blockquote><p><img loading="lazy" alt="GBN2" src="/assets/images/GBN2-ba074767c648deeaf2f3157234726c42.png" width="1127" height="635" class="img_ev3q"></p><blockquote><p>发送窗口不能无限大，与使用的编号的比特数有关，二进制表示。</p><p>很简单，就是1比特编号0和1,</p><p>同理2比特编号0-3，二进制表示就是00，01，10，11。</p><p>如果用1比特编号，却要4个窗口长度，那么窗口内数据编号都编不过来，直接乱套了</p><p>GBN的优缺点也显而易见，优点是相对于上面的停止等待协议，明显提高了信道利用率，缺点是因为重传机制的原因，导致已经收到数据却需要强行丢弃，进而造成浪费</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="413-选择重传协议sr">4.1.3 选择重传协议（SR）<a class="hash-link" href="#413-选择重传协议sr" title="Direct link to heading">​</a></h4><p>吸取了GBN协议的教训，我们打算尝试只重传错误的帧，这样的话就不用浪费资源把已经收到的帧再重传一次了。
在GBN中，仅有接收端有一个窗口来存放数据帧，在SR中，两者都有窗口了。
和GBN的区别其实就是做了一个数据缓存，已经收到的帧不用扔了，等待之前因意外丢失的帧收到的时候确认即可，但是只能缓存窗口尺寸内的包含的帧（注释：缓存不可能无限大）
SR运行过程
注释：2帧丢失之后仍然在发送，但是2帧丢失之后只是缓存，并没有移动窗口；它可以继续接受窗口范围内排在2帧后面的数据帧，直至最后2帧收到后一次性确认窗口内的所有已经收到的帧，再移动窗口。</p><p><img loading="lazy" alt="选择重传协议" src="/assets/images/选择重传协议-d8ff8815f2572655a76a5f6a8734cbe8.png" width="1116" height="629" class="img_ev3q"></p><p>同样的，因为编号的问题，发送窗口不能无限大
当发送窗口最后和接受窗口<strong>大小相同</strong>时，利用率比较高</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="5-介质访问控制技术">5. 介质访问控制技术<a class="hash-link" href="#5-介质访问控制技术" title="Direct link to heading">​</a></h2><blockquote><p>就是让节点之间的通信不会进行相互干扰</p></blockquote><p><img loading="lazy" alt="介质访问控制" src="/assets/images/介质访问控制-2d84f7277a2714c4fccd70310ce0932a.png" width="947" height="435" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="51-信道划分协议">5.1 信道划分协议<a class="hash-link" href="#51-信道划分协议" title="Direct link to heading">​</a></h3><blockquote><p>虽然使用一条共享信道，但是通过多路复用技术组合进行传输，提高了信道的利用率</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="511-频分多路复用fdm">5.1.1 频分多路复用FDM<a class="hash-link" href="#511-频分多路复用fdm" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="频分多路复用" src="/assets/images/频分多路复用-07f57e8a2cdf68b8b079c0403996809e.png" width="1004" height="473" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="512-时分多路复用tdm">5.1.2 时分多路复用TDM<a class="hash-link" href="#512-时分多路复用tdm" title="Direct link to heading">​</a></h4><blockquote><p>TDM的缺点就是利用率低，所以又衍生出了STDM</p></blockquote><p><img loading="lazy" alt="时分多路复用" src="/assets/images/时分多路复用-bb1fbb143bc8cb6849b91bc69aa5e6ab.png" width="1027" height="465" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="513-统计时分复用stdm">5.1.3 统计时分复用STDM<a class="hash-link" href="#513-统计时分复用stdm" title="Direct link to heading">​</a></h4><blockquote><p>STDM的原则是先到先走，满了就发，相对于TDM提高了利用率</p></blockquote><p><img loading="lazy" alt="统计时分复用" src="/assets/images/统计时分复用-5b52840c3042e976e137e31a463d1f33.png" width="1034" height="535" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="514-码分多路复用cdm">5.1.4 码分多路复用CDM<a class="hash-link" href="#514-码分多路复用cdm" title="Direct link to heading">​</a></h4><blockquote><p>每个节点分配一种不同的编码，每个节点使用其唯一的编码来对发送的数据进行编码（如果精心选择编码，不同节点能同时传输）</p></blockquote><p><img loading="lazy" alt="码分多路复用" src="/assets/images/码分多路复用-b2959e8a4edfc606a817d015479ad5cc.png" width="1064" height="442" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="52-随机接入协议">5.2 随机接入协议<a class="hash-link" href="#52-随机接入协议" title="Direct link to heading">​</a></h3><blockquote><p>所有用户都可以随机发送信息，发送时可以占用全部带宽，理论上个人使用时比静态分配信道的速度更快</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="521-aloha协议">5.2.1 ALOHA协议<a class="hash-link" href="#521-aloha协议" title="Direct link to heading">​</a></h4><blockquote><p>帧到达节点时，立刻传输。如果发生碰撞，节点将立即(在完全传输碰撞帧后)以概率p重传。否则，等待一个帧传输时间，再以概率p重传。信道有效传输速率实际不是R bps，而是时隙ALOHA的一半</p></blockquote><p><img loading="lazy" alt="ALOHA协议1" src="/assets/images/ALOHA协议1-0c77bf8641556bfc2e33eef968fa9825.png" width="1049" height="505" class="img_ev3q"></p><blockquote><p>时隙ALOHA协议</p><p>时间被划分为时隙，每个节点的时间同步，帧的传输只在时隙的开始时进行。如果发生碰撞，在下一个时隙开始时以概率p重传，否则等待一个时隙再以概率p重传…（信道有效传输速率实际不是R bps，而是0.37R bps）</p></blockquote><p><img loading="lazy" alt="ALOHA协议2" src="/assets/images/ALOHA协议2-89fac729cac0c8dd2a9a639bf3fd0864.png" width="990" height="462" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="522-csma协议载波侦听多路访问">5.2.2 CSMA协议(载波侦听多路访问)<a class="hash-link" href="#522-csma协议载波侦听多路访问" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="CSMA协议" src="/assets/images/CSMA协议-344f409a84491d7673256a4fa438ba32.png" width="1033" height="499" class="img_ev3q"></p><table><thead><tr><th>名称</th><th>描述</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1-坚持CSMA</td><td>发送信息时监听信道，一空闲下来就立即传输，信道忙也一直监听，如果发送时冲突等待随机时长后再监听</td><td>立即发送，利用率高</td><td>如果多台设备同时监听，那么会发生冲突</td></tr><tr><td>非坚持CSMA</td><td>发送信息时监听信道，如果空闲就立即传输，信道忙就随机等待一段时间后再监听</td><td>冲突发生的几率少</td><td>因为需要等待，所以利用率不高</td></tr><tr><td>p-坚持CSMA</td><td>发送信息时监听信道，空闲时以概率P进行传输，概率1-p不传输。信道忙就随机等待一段时间后再监听</td><td>冲突减少的同时效率也比较高</td><td>即使发生冲突也要坚持发送数据，资源被浪费</td></tr></tbody></table><h4 class="anchor anchorWithStickyNavbar_LWe7" id="523-csmacd协议">5.2.3 CSMA/CD协议<a class="hash-link" href="#523-csmacd协议" title="Direct link to heading">​</a></h4><blockquote><p>概述</p><p>因为链路实际有长短，发送数据需要时间，这个时间内可能就被其他节点当成空闲状态导致发生碰撞。
先侦听信道，如果没有其它节点在使用信道，则传输数据。但是有碰撞检测，如果发生碰撞，会停止传输剩下的数据，等待一个随机时间(通常比传输一帧短)后，再进行尝试。</p><p>知道自己发生碰撞的最长时间是2τ（两倍的传播时延），就是一去一回</p></blockquote><p><img loading="lazy" alt="CSMA-CD协议" src="/assets/images/CSMA-CD协议-b9f8e6b1679d154377f36bbd0a3232f9.png" width="1051" height="502" class="img_ev3q"></p><p>图示传播时延对载波监听的影响</p><p><img loading="lazy" alt="传播时延对载波监听的影响" src="/assets/images/传播时延对载波监听的影响-e923fc8384b23fc457a8145abaf7d6cc.png" width="1144" height="602" class="img_ev3q"></p><p><img loading="lazy" alt="传播时延对载波监听的影响1" src="/assets/images/传播时延对载波监听的影响1-ddc9880403b2884a16042120b96bd36d.png" width="910" height="268" class="img_ev3q"></p><p><img loading="lazy" alt="传播时延对载波监听的影响2" src="/assets/images/传播时延对载波监听的影响2-fc0c08426d1a6136d34e6c0656c28ca0.png" width="1090" height="524" class="img_ev3q">
由此我们可以想到最小帧长的问题，因为如果帧太短，帧都发送完了才检测到碰撞导致停止，导致无法停止碰撞</p><p><img loading="lazy" alt="传播时延对载波监听的影响3" src="/assets/images/传播时延对载波监听的影响3-77e119d88276f09498a6b6daf4e5c2ef.png" width="910" height="268" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="524-csmaca协议">5.2.4 CSMA/CA协议<a class="hash-link" href="#524-csmaca协议" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="CSMA-CA协议1" src="/assets/images/CSMA-CA协议1-717615fb593a89ec9e73108d6ba3c5ca.png" width="1011" height="330" class="img_ev3q"></p><p><img loading="lazy" alt="CSMA-CA协议2" src="/assets/images/CSMA-CA协议2-cff7c3a550004edcc86a9df37a41d90d.png" width="1079" height="445" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="525-csmacd-与-csmaca的区别">5.2.5 CSMA/CD 与 CSMA/CA的区别<a class="hash-link" href="#525-csmacd-与-csmaca的区别" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="CSMA-CD与CSMA-CA的区别" src="/assets/images/CSMA-CD与CSMA-CA的区别-05c405aac51d1d6fd973dffcba0a434d.png" width="1097" height="360" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="53-轮询访问介质访问控制">5.3 轮询访问介质访问控制<a class="hash-link" href="#53-轮询访问介质访问控制" title="Direct link to heading">​</a></h3><p>主要包括两大类，一个是<strong>轮询协议</strong>，另一个是<strong>令牌传递协议</strong></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="531-轮询协议">5.3.1 轮询协议<a class="hash-link" href="#531-轮询协议" title="Direct link to heading">​</a></h4><p>就是选出一个代表，让他控制所有的传输
注释：
轮询开销在随着服务的节点越多，需要用于查询是否发送数据发送的数据帧也就越多，会造成一定开销
等待延迟就是因为这是轮流“邀请”，所以难免某个节点需要发送数据，但是主节点还在较远的需要里有需求的节点那边，导致需求得不到立即响应
单点故障很好理解，就是代表挂了</p><p><img loading="lazy" alt="轮询协议" src="/assets/images/轮询协议-fb08772ab7fb8c460856682f857a52fb.png" width="842" height="523" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="532-令牌传递协议">5.3.2 令牌传递协议<a class="hash-link" href="#532-令牌传递协议" title="Direct link to heading">​</a></h4><blockquote><p>注释：在节点之间没有收发数据的需求时，令牌在节点之间循环。</p><p>发送数据的流程</p><p>----》当一个节点需要时就可以获得这个令牌。然后修改这个令牌的状态（空闲-&gt;占用）</p><p>----》再将令牌与数据帧结合，让其在节点构成的环之间流动</p><p>----》不是目的地的节点收到令牌也不接受，直接略过，目标节点收到信息并复制一份到本地（传输完成），因为是个闭环，所以发送节点最后得到令牌</p><p>----》最后，发送令牌的节点对令牌的内容进行检查，如果发现数据出错还要重新发一遍</p><p>问题基本和轮询协议相同</p></blockquote><p><img loading="lazy" alt="令牌传递协议" src="/assets/images/令牌传递协议-974c8158d5bcda02187f73633849592f.png" width="1075" height="518" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="6局域网">6.局域网<a class="hash-link" href="#6局域网" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="61-局域网的概念">6.1 局域网的概念<a class="hash-link" href="#61-局域网的概念" title="Direct link to heading">​</a></h3><p>概括：范围大小，速度快，延迟低，节点平等</p><p><img loading="lazy" alt="局域网" src="/assets/images/局域网-74228180800e006720d78d13e9ecb90c.png" width="1035" height="363" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="611-局域网的网络拓扑结构">6.1.1 局域网的网络拓扑结构<a class="hash-link" href="#611-局域网的网络拓扑结构" title="Direct link to heading">​</a></h4><p>常用的是<strong>总线型拓扑</strong></p><p><img loading="lazy" alt="局域网拓扑结构" src="/assets/images/局域网拓扑结构-e4c51bd91c167e5a497ee95ba3678dec.png" width="1061" height="571" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="612-局域网的传播介质">6.1.2 局域网的传播介质<a class="hash-link" href="#612-局域网的传播介质" title="Direct link to heading">​</a></h4><table><thead><tr><th>局域网</th><th>常用介质</th></tr></thead><tbody><tr><td>有线局域网</td><td>双绞线，同轴电缆，光纤</td></tr><tr><td>无线局域网</td><td>电磁波</td></tr></tbody></table><h4 class="anchor anchorWithStickyNavbar_LWe7" id="613-局域网介质访问方法">6.1.3 局域网介质访问方法<a class="hash-link" href="#613-局域网介质访问方法" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="局域网介质访问方法" src="/assets/images/局域网介质访问方法-1b2ad783ab42d5f8e2a194ccb12ea80b.png" width="976" height="322" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="62-局域网的分类">6.2 局域网的分类<a class="hash-link" href="#62-局域网的分类" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="局域网的分类" src="/assets/images/局域网的分类-f6641950a42a081fb877896fc4828969.png" width="1044" height="449" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="63-ieee802标准">6.3 IEEE802标准<a class="hash-link" href="#63-ieee802标准" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="IEEE802标准" src="/assets/images/IEEE802标准-0e938eb910024adf89165cd166a5f3f5.png" width="791" height="631" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="631-ieee802描述的局域网参考模型">6.3.1 IEEE802描述的局域网参考模型<a class="hash-link" href="#631-ieee802描述的局域网参考模型" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="IEEE802描述的局域网参考模型" src="/assets/images/IEEE802描述的局域网参考模型-897fbfda602727b77ef75e8835d6cb61.png" width="1080" height="496" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="64以太网">6.4以太网<a class="hash-link" href="#64以太网" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="641-以太网概念">6.4.1 以太网概念<a class="hash-link" href="#641-以太网概念" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="以太网概念" src="/assets/images/以太网概念-177f0886397710caedbef41c783fb068.png" width="1059" height="490" class="img_ev3q">
<img loading="lazy" alt="以太网特点" src="/assets/images/以太网特点-df9c0dab47c2fe73b3c0a429d890ea97.png" width="1028" height="238" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="642-以太网的发展">6.4.2 以太网的发展<a class="hash-link" href="#642-以太网的发展" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="以太网的发展" src="/assets/images/以太网的发展-40e177227db5312d7e906fd6735ada98.png" width="1006" height="513" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="643-适配器和mac地址">6.4.3 适配器和MAC地址<a class="hash-link" href="#643-适配器和mac地址" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="适配器和MAC地址" src="/assets/images/适配器和MAC地址-6727e5cdab7f59e597620333080c591e.png" width="1080" height="444" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="644-以太网mac帧">6.4.4 以太网MAC帧<a class="hash-link" href="#644-以太网mac帧" title="Direct link to heading">​</a></h4><blockquote><p>注释：
1.这里的mac层指的是数据链路层</p><p>2.之前说过数据链路层将上一层ip数据包加头加尾</p><p>头就是目标地址（6字节），源地址（6字节），类型（2字节）</p><p>尾就是FCS（帧检验序列），（4字节）</p><p>3.前导码<strong>不是MAC帧的一部分</strong>，目的是使时钟同步</p><p>4.为什么数据长度时46~1500？</p><p>因为有最小传输字节64字节，mac占用6+6+2+4=18，所以数据最小为64-18=46，1500则是规定的默认最大字节，没有理由</p></blockquote><p><img loading="lazy" alt="以太网MAC帧" src="/assets/images/以太网MAC帧-53f1010514aa041a69d5835874f372c6.png" width="928" height="456" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="645-10base-t以太网">6.4.5 10BASE-T以太网<a class="hash-link" href="#645-10base-t以太网" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="10BASE-T以太网" src="/assets/images/10BASE-T以太网-bad0dde223485e9049e01c1c63be3405.png" width="980" height="317" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="646-高速以太网">6.4.6 高速以太网<a class="hash-link" href="#646-高速以太网" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="高速以太网" src="/assets/images/高速以太网-2b454b0a21387b10c868d22a635a6d3f.png" width="914" height="527" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="65-无线局域网">6.5 无线局域网<a class="hash-link" href="#65-无线局域网" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="802.11的MAC帧头格式" src="/assets/images/802.11的MAC帧头格式-f4adea4e5a3c2db184c3ffb5f678f5d7.png" width="804" height="354" class="img_ev3q">
<img loading="lazy" alt="802.11的MAC帧头格式1" src="/assets/images/802.11的MAC帧头格式1-7dfc2bbe57f16c7ecfa9ecde57a3a7f8.png" width="1008" height="493" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="651-两种无线局域网">6.5.1 两种无线局域网<a class="hash-link" href="#651-两种无线局域网" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="有固定基础设施无线局域网" src="/assets/images/有固定基础设施无线局域网-fe17bd87860f5291d8a7c2b890638759.png" width="1014" height="542" class="img_ev3q"></p><p><img loading="lazy" alt="无固定基础设施无线局域网" src="/assets/images/无固定基础设施无线局域网-039c845a614339925b5610a3a9cad1c8.png" width="1087" height="532" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="7广域网">7.广域网<a class="hash-link" href="#7广域网" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="71-广域网的概述">7.1 广域网的概述<a class="hash-link" href="#71-广域网的概述" title="Direct link to heading">​</a></h3><p>概括一下，一个字大
<img loading="lazy" alt="广域网" src="/assets/images/广域网-ed0d38ec9f60318aaa39b37136d761be.png" width="1070" height="568" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="72-ppp协议point-to-point-protocol">7.2 PPP协议（Point-to-Point Protocol）<a class="hash-link" href="#72-ppp协议point-to-point-protocol" title="Direct link to heading">​</a></h3><p>PPP协议是目前<strong>使用最广泛</strong>的数据链路层协议，拨号基本都是PPP协议
PPP协议<strong>仅支持全双工</strong>链路</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="721-ppp协议需要满足的要求">7.2.1 PPP协议需要满足的要求<a class="hash-link" href="#721-ppp协议需要满足的要求" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="PPP协议需要满足的要求" src="/assets/images/PPP协议需要满足的要求-f5ba470ec7e7f6b87d79cfe8a2f5e524.png" width="1031" height="447" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="722-ppp协议不需要满足的要求">7.2.2 PPP协议不需要满足的要求<a class="hash-link" href="#722-ppp协议不需要满足的要求" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="PPP协议不需要满足的要求" src="/assets/images/PPP协议不需要满足的要求-2c54e8b7cf7a9c2ec5153403bebdcb78.png" width="712" height="307" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="723-ppp协议组成成分以及功能">7.2.3 PPP协议组成成分以及功能<a class="hash-link" href="#723-ppp协议组成成分以及功能" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="PPP协议组成成分以及功能" src="/assets/images/PPP协议组成成分以及功能-3471307a0a5058c887e12774a8862b0a.png" width="998" height="319" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="724-ppp协议的帧格式">7.2.4 PPP协议的帧格式<a class="hash-link" href="#724-ppp协议的帧格式" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="PPP协议的帧格式" src="/assets/images/PPP协议的帧格式-ea12adb7341c4f3669a30ce843fef599.png" width="966" height="547" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="73-hdlc协议high-level-data-link-control">7.3 HDLC协议（High-Level Data Link Control）<a class="hash-link" href="#73-hdlc协议high-level-data-link-control" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="731-hdlc协议概述">7.3.1 HDLC协议概述<a class="hash-link" href="#731-hdlc协议概述" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="HDLC协议概述" src="/assets/images/HDLC协议概述-cea25c43409b4068db683aad51a215fe.png" width="1076" height="259" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="732-hdlc的三种站">7.3.2 HDLC的三种站<a class="hash-link" href="#732-hdlc的三种站" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="HDLC的三种站" src="/assets/images/HDLC的三种站-ea71346c37cfb749bea803ef6eb578ad.png" width="1000" height="407" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="733-hdlc的帧格式">7.3.3 HDLC的帧格式<a class="hash-link" href="#733-hdlc的帧格式" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="HDLC的帧格式" src="/assets/images/HDLC的帧格式-5abddc44bd811e860dca390133771823.png" width="1007" height="495" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="74-ppp协议和hdlc协议对比">7.4 PPP协议和HDLC协议对比<a class="hash-link" href="#74-ppp协议和hdlc协议对比" title="Direct link to heading">​</a></h3><p>为什么HDLC协议更可靠，但是我们使用PPP协议？
因为现在网络要求高，数据链路层本来就是不可靠的尽力传输，差错控制这些复杂的交给了TCP等</p><p><img loading="lazy" alt="PPP协议和HDLC协议对比" src="/assets/images/PPP协议和HDLC协议对比-953174a7480959db27dad29a24eaa8dc.png" width="967" height="593" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="8-链路层设备">8. 链路层设备<a class="hash-link" href="#8-链路层设备" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="81-网桥bridge">8.1 网桥（Bridge）<a class="hash-link" href="#81-网桥bridge" title="Direct link to heading">​</a></h3><p>使用网桥时，由于网桥会根据mac地址进行过滤，所以<strong>不会形成冲突域</strong></p><p><img loading="lazy" alt="链路层扩展以太网" src="/assets/images/链路层扩展以太网-f7d53d2858402df805bb7d916be97f88.png" width="1049" height="515" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="811-两种网桥">8.1.1 两种网桥<a class="hash-link" href="#811-两种网桥" title="Direct link to heading">​</a></h4><h5 class="anchor anchorWithStickyNavbar_LWe7" id="透明网桥">透明网桥<a class="hash-link" href="#透明网桥" title="Direct link to heading">​</a></h5><p>通过自学习来构建转发表。每一个通过网桥的数据包都会被记录下网桥收到数据时数据对应的地址和网桥自己的接口，通过许许多多的数据包的构造的缓存，网桥就可以知道哪个数据包在哪个接口，以后如果要穿数据包就知道要往哪个接口发送数据包了</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="原路由网桥">原路由网桥<a class="hash-link" href="#原路由网桥" title="Direct link to heading">​</a></h5><p>在发送时，直接将最佳路径放到帧首部。那么网桥如何获得最佳路径？通过广播方式想目标地址发送广播，此时可能会经过不同路由产生不同的路径，目标地址收到后再将每一条路径都发一个响应帧给网桥，网桥经过对比就知道哪个接口最快了</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="82-交换机">8.2 交换机<a class="hash-link" href="#82-交换机" title="Direct link to heading">​</a></h3><blockquote><p>网桥接口越来越多，网桥就变成了交换机</p><p>交换机的任务是接收入链路层帧并将它们转发到出链路</p><p>交换机自身对节点透明：某节点向另一节点寻址一个帧，顺利地将该帧发送进LAN，而不知道这个帧经过了某个交换机的接收与转发</p></blockquote><p>1）交换机转发与过滤
过滤：交换机决定一个帧是应该转发还是应该丢弃
转发：决定一个帧应该被导向哪个接口</p><p>2）自学习(即插即用)
交换机表是自动、动态、自治地建立的，没有来自网络管理员或配置协议的任何干预。换句话说，交换机是自学习的
交换机表初始为空
源地址为DD-DD-DD-DD-DD-DD的帧从接口x到达时，如果不存在则新建一项；存在则更新当前时间
如果一段时间后，在x接口没有来自DD-DD-DD-DD-DD-DD的帧，则将该表项删除</p><p><img loading="lazy" alt="以太网交换机的两种交换方式" src="/assets/images/以太网交换机的两种交换方式-c76d629dba88e632a782a60c7833bcd9.png" width="1002" height="393" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="83-冲突域和广播域">8.3 冲突域和广播域<a class="hash-link" href="#83-冲突域和广播域" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="冲突域和广播域" src="/assets/images/冲突域和广播域-4c00d385fc2b2d1cd35a8c1f2c34b5e6.png" width="1063" height="524" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="9-数据链路层总结">9. 数据链路层总结<a class="hash-link" href="#9-数据链路层总结" title="Direct link to heading">​</a></h2><p><img loading="lazy" alt="数据链路层总结" src="/assets/images/数据链路层总结-600d2aaf58bad5a2abe78e51630f7f8c.png" width="5103" height="7966" class="img_ev3q"></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/network/计算机网络-3.数据链路层.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/network/计算机网络-2.物理层"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">2.物理层（Physical Layer）</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/network/计算机网络-4.网络层"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">4.网络层（Network Layer）</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-基本概念" class="table-of-contents__link toc-highlight">1. 基本概念</a><ul><li><a href="#链路层编址" class="table-of-contents__link toc-highlight">链路层编址</a></li><li><a href="#mac地址" class="table-of-contents__link toc-highlight">MAC地址</a></li><li><a href="#arp协议地址解析协议" class="table-of-contents__link toc-highlight">ARP协议(地址解析协议)</a></li><li><a href="#广播的概念" class="table-of-contents__link toc-highlight">广播的概念</a></li></ul></li><li><a href="#2-封装成帧与透明传输" class="table-of-contents__link toc-highlight">2. 封装成帧与透明传输</a><ul><li><a href="#21-透明传输的实现方法" class="table-of-contents__link toc-highlight">2.1 透明传输的实现方法</a><ul><li><a href="#211-字符计数法" class="table-of-contents__link toc-highlight">2.1.1 字符计数法</a></li><li><a href="#212-字符填充法" class="table-of-contents__link toc-highlight">2.1.2 字符填充法</a></li><li><a href="#213-零比特填充法" class="table-of-contents__link toc-highlight">2.1.3 零比特填充法</a></li><li><a href="#214-违规编码法" class="table-of-contents__link toc-highlight">2.1.4 违规编码法</a></li></ul></li></ul></li><li><a href="#3-差错控制" class="table-of-contents__link toc-highlight">3. 差错控制</a><ul><li><a href="#31-差错是什么从哪来的" class="table-of-contents__link toc-highlight">3.1 差错是什么，从哪来的</a></li><li><a href="#32-为什么要在数据链路层进行差错控制" class="table-of-contents__link toc-highlight">3.2 为什么要在数据链路层进行差错控制？</a></li><li><a href="#33-检错编码奇偶校验码循环冗余码crc" class="table-of-contents__link toc-highlight">3.3 检错编码（奇偶校验码，循环冗余码CRC）</a><ul><li><a href="#331-奇偶校验码" class="table-of-contents__link toc-highlight">3.3.1 奇偶校验码</a></li><li><a href="#332-循环冗余码crc" class="table-of-contents__link toc-highlight">3.3.2 循环冗余码CRC</a></li></ul></li><li><a href="#34-纠错编码海明码" class="table-of-contents__link toc-highlight">3.4 纠错编码（海明码）</a><ul><li><a href="#第一步-确认校验码位数r" class="table-of-contents__link toc-highlight">第一步 确认校验码位数r</a></li><li><a href="#第二步-确定校验码和数据的位置" class="table-of-contents__link toc-highlight">第二步 确定校验码和数据的位置</a></li><li><a href="#第三步-求出校验码的值" class="table-of-contents__link toc-highlight">第三步 求出校验码的值</a></li><li><a href="#第四步-检测并纠错" class="table-of-contents__link toc-highlight">第四步 检测并纠错</a></li></ul></li></ul></li><li><a href="#4-数据链路层的流量控制和可靠传输" class="table-of-contents__link toc-highlight">4. 数据链路层的流量控制和可靠传输</a><ul><li><a href="#41-流量控制与可靠传输" class="table-of-contents__link toc-highlight">4.1 流量控制与可靠传输</a><ul><li><a href="#411-停止等待协议stop-and-wait" class="table-of-contents__link toc-highlight">4.1.1 停止等待协议（Stop-and-Wait）</a></li><li><a href="#412-后退n帧协议gbn" class="table-of-contents__link toc-highlight">4.1.2 后退N帧协议（GBN）</a></li><li><a href="#413-选择重传协议sr" class="table-of-contents__link toc-highlight">4.1.3 选择重传协议（SR）</a></li></ul></li></ul></li><li><a href="#5-介质访问控制技术" class="table-of-contents__link toc-highlight">5. 介质访问控制技术</a><ul><li><a href="#51-信道划分协议" class="table-of-contents__link toc-highlight">5.1 信道划分协议</a><ul><li><a href="#511-频分多路复用fdm" class="table-of-contents__link toc-highlight">5.1.1 频分多路复用FDM</a></li><li><a href="#512-时分多路复用tdm" class="table-of-contents__link toc-highlight">5.1.2 时分多路复用TDM</a></li><li><a href="#513-统计时分复用stdm" class="table-of-contents__link toc-highlight">5.1.3 统计时分复用STDM</a></li><li><a href="#514-码分多路复用cdm" class="table-of-contents__link toc-highlight">5.1.4 码分多路复用CDM</a></li></ul></li><li><a href="#52-随机接入协议" class="table-of-contents__link toc-highlight">5.2 随机接入协议</a><ul><li><a href="#521-aloha协议" class="table-of-contents__link toc-highlight">5.2.1 ALOHA协议</a></li><li><a href="#522-csma协议载波侦听多路访问" class="table-of-contents__link toc-highlight">5.2.2 CSMA协议(载波侦听多路访问)</a></li><li><a href="#523-csmacd协议" class="table-of-contents__link toc-highlight">5.2.3 CSMA/CD协议</a></li><li><a href="#524-csmaca协议" class="table-of-contents__link toc-highlight">5.2.4 CSMA/CA协议</a></li><li><a href="#525-csmacd-与-csmaca的区别" class="table-of-contents__link toc-highlight">5.2.5 CSMA/CD 与 CSMA/CA的区别</a></li></ul></li><li><a href="#53-轮询访问介质访问控制" class="table-of-contents__link toc-highlight">5.3 轮询访问介质访问控制</a><ul><li><a href="#531-轮询协议" class="table-of-contents__link toc-highlight">5.3.1 轮询协议</a></li><li><a href="#532-令牌传递协议" class="table-of-contents__link toc-highlight">5.3.2 令牌传递协议</a></li></ul></li></ul></li><li><a href="#6局域网" class="table-of-contents__link toc-highlight">6.局域网</a><ul><li><a href="#61-局域网的概念" class="table-of-contents__link toc-highlight">6.1 局域网的概念</a><ul><li><a href="#611-局域网的网络拓扑结构" class="table-of-contents__link toc-highlight">6.1.1 局域网的网络拓扑结构</a></li><li><a href="#612-局域网的传播介质" class="table-of-contents__link toc-highlight">6.1.2 局域网的传播介质</a></li><li><a href="#613-局域网介质访问方法" class="table-of-contents__link toc-highlight">6.1.3 局域网介质访问方法</a></li></ul></li><li><a href="#62-局域网的分类" class="table-of-contents__link toc-highlight">6.2 局域网的分类</a></li><li><a href="#63-ieee802标准" class="table-of-contents__link toc-highlight">6.3 IEEE802标准</a><ul><li><a href="#631-ieee802描述的局域网参考模型" class="table-of-contents__link toc-highlight">6.3.1 IEEE802描述的局域网参考模型</a></li></ul></li><li><a href="#64以太网" class="table-of-contents__link toc-highlight">6.4以太网</a><ul><li><a href="#641-以太网概念" class="table-of-contents__link toc-highlight">6.4.1 以太网概念</a></li><li><a href="#642-以太网的发展" class="table-of-contents__link toc-highlight">6.4.2 以太网的发展</a></li><li><a href="#643-适配器和mac地址" class="table-of-contents__link toc-highlight">6.4.3 适配器和MAC地址</a></li><li><a href="#644-以太网mac帧" class="table-of-contents__link toc-highlight">6.4.4 以太网MAC帧</a></li><li><a href="#645-10base-t以太网" class="table-of-contents__link toc-highlight">6.4.5 10BASE-T以太网</a></li><li><a href="#646-高速以太网" class="table-of-contents__link toc-highlight">6.4.6 高速以太网</a></li></ul></li><li><a href="#65-无线局域网" class="table-of-contents__link toc-highlight">6.5 无线局域网</a><ul><li><a href="#651-两种无线局域网" class="table-of-contents__link toc-highlight">6.5.1 两种无线局域网</a></li></ul></li></ul></li><li><a href="#7广域网" class="table-of-contents__link toc-highlight">7.广域网</a><ul><li><a href="#71-广域网的概述" class="table-of-contents__link toc-highlight">7.1 广域网的概述</a></li><li><a href="#72-ppp协议point-to-point-protocol" class="table-of-contents__link toc-highlight">7.2 PPP协议（Point-to-Point Protocol）</a><ul><li><a href="#721-ppp协议需要满足的要求" class="table-of-contents__link toc-highlight">7.2.1 PPP协议需要满足的要求</a></li><li><a href="#722-ppp协议不需要满足的要求" class="table-of-contents__link toc-highlight">7.2.2 PPP协议不需要满足的要求</a></li><li><a href="#723-ppp协议组成成分以及功能" class="table-of-contents__link toc-highlight">7.2.3 PPP协议组成成分以及功能</a></li><li><a href="#724-ppp协议的帧格式" class="table-of-contents__link toc-highlight">7.2.4 PPP协议的帧格式</a></li></ul></li><li><a href="#73-hdlc协议high-level-data-link-control" class="table-of-contents__link toc-highlight">7.3 HDLC协议（High-Level Data Link Control）</a><ul><li><a href="#731-hdlc协议概述" class="table-of-contents__link toc-highlight">7.3.1 HDLC协议概述</a></li><li><a href="#732-hdlc的三种站" class="table-of-contents__link toc-highlight">7.3.2 HDLC的三种站</a></li><li><a href="#733-hdlc的帧格式" class="table-of-contents__link toc-highlight">7.3.3 HDLC的帧格式</a></li></ul></li><li><a href="#74-ppp协议和hdlc协议对比" class="table-of-contents__link toc-highlight">7.4 PPP协议和HDLC协议对比</a></li></ul></li><li><a href="#8-链路层设备" class="table-of-contents__link toc-highlight">8. 链路层设备</a><ul><li><a href="#81-网桥bridge" class="table-of-contents__link toc-highlight">8.1 网桥（Bridge）</a><ul><li><a href="#811-两种网桥" class="table-of-contents__link toc-highlight">8.1.1 两种网桥</a><ul><li><a href="#透明网桥" class="table-of-contents__link toc-highlight">透明网桥</a></li><li><a href="#原路由网桥" class="table-of-contents__link toc-highlight">原路由网桥</a></li></ul></li></ul></li><li><a href="#82-交换机" class="table-of-contents__link toc-highlight">8.2 交换机</a></li><li><a href="#83-冲突域和广播域" class="table-of-contents__link toc-highlight">8.3 冲突域和广播域</a></li></ul></li><li><a href="#9-数据链路层总结" class="table-of-contents__link toc-highlight">9. 数据链路层总结</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">计算机</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/operating-system/操作系统的基本概念">数据结构</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/operating-system/操作系统的基本概念">操作系统</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/network/计算机网络-1.概述">计算机网络</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/The-End-Hero/xiping-work-docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 xiping.wang, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.edc8b151.js"></script>
<script src="/assets/js/main.d12d1af5.js"></script>
</body>
</html>
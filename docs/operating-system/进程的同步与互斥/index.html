<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-operating-system/进程的同步与互斥">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.1">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="知识库 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="知识库 Atom Feed"><title data-rh="true">3. 进程的同步与互斥 | 知识库</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://doc.xiping.work//docs/operating-system/进程的同步与互斥"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="3. 进程的同步与互斥 | 知识库"><meta data-rh="true" name="description" content="1. 进程的同步与互斥"><meta data-rh="true" property="og:description" content="1. 进程的同步与互斥"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://doc.xiping.work//docs/operating-system/进程的同步与互斥"><link data-rh="true" rel="alternate" href="https://doc.xiping.work//docs/operating-system/进程的同步与互斥" hreflang="en"><link data-rh="true" rel="alternate" href="https://doc.xiping.work//docs/operating-system/进程的同步与互斥" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.984b0bbb.css">
<link rel="preload" href="/assets/js/runtime~main.61241a0c.js" as="script">
<link rel="preload" href="/assets/js/main.01c9ea38.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><div class="announcementBar_mb4j" style="background-color:#544a31;color:#dbdce7" role="banner"><div class="announcementBarContent_xLdY">⭐️ 如果这个网站能帮助到你，欢迎给一个star支持作者<a target="_blank" rel="noopener noreferrer" href="https://github.com/The-End-Hero/xiping-work-docusaurus">GitHub</a></div></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">知识库</b></a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">计算机基础</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/network/计算机网络-1.概述">计算机网络</a></li><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/operating-system/操作系统的基本概念">操作系统</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">数据结构与算法</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/data-structures/数据结构-链表">数据结构</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">前端</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/react/状态管理">react相关</a></li><li><a class="dropdown__link" href="/docs/front-end-engineering/包管理工具">工程化相关</a></li></ul></div><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/The-End-Hero" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG menuWithAnnouncementBar_GW3s"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/operating-system/操作系统的基本概念">操作系统</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/operating-system/操作系统的基本概念">1.概述</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/docs/operating-system/进程与线程">2.进程管理</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/operating-system/进程与线程">1. 进程与线程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/operating-system/处理机的调度">2. 处理机的调度</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/operating-system/进程的同步与互斥">3. 进程的同步与互斥</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/operating-system/死锁">4. 死锁</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/operating-system/内存管理的概念">3.内存管理</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/operating-system/文件系统">4.文件管理</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/operating-system/I-O管理概述">5.I/O管理</a></div></li></ul></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">操作系统</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">2.进程管理</span><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">3. 进程的同步与互斥</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>3. 进程的同步与互斥</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1-进程的同步与互斥">1. 进程的同步与互斥<a class="hash-link" href="#1-进程的同步与互斥" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="0-思维导图">0. 思维导图<a class="hash-link" href="#0-思维导图" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="同步与互斥" src="/assets/images/同步与互斥-5ff64c5dc99f0acdad8dd5b97eb66e88.png" width="1536" height="667" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-进程同步">1. 进程同步<a class="hash-link" href="#1-进程同步" title="Direct link to heading">​</a></h3><ul><li><strong>同步也称为直接制约关系。</strong></li><li>在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系,如等待、传递信息等，引入了进程同步的概念。进程同步是为了解决进程的异步问题。</li><li>一个简单的例子来理解这个概念。</li><li>例如，让系统计算1 + 2x3，假设系统产生两个进程: 一个是加法进程，一个是乘法进程。要让计算结果是正确的，一定要让加法进程发生在乘法进程之后,但实际上操作系统具有<strong>异步性</strong>,若不加以制约，加法进程发生在乘法进程之前是绝对有可能的，因此要制定一定的机制去约束加法进程，让它在乘法进程完成之后才发生。</li></ul><blockquote><p>异步性：进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-进程互斥">2. 进程互斥<a class="hash-link" href="#2-进程互斥" title="Direct link to heading">​</a></h3><ul><li><strong>互斥，亦称间接制约关系</strong>。<strong>进程互斥</strong>指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问<strong>临界资源</strong>的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</li><li>在这里需复习一下<strong>临界资源</strong>的概念。</li><li>我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</li><li>对临界资源的访问，必须互斥地进行。</li></ul><p><img loading="lazy" alt="临界资源的访问" src="/assets/images/临界资源的访问-dd043e7b49c24a8c635e2ed3ed160fde.png" width="1282" height="655" class="img_ev3q"></p><ul><li>为了禁止两个进程同时进入<strong>临界区</strong>，需遵循以下准则</li></ul><p><img loading="lazy" alt="临界区访问规则" src="/assets/images/临界区访问规则-ac78a7bfffd1f2ee8f393e623cfe4c2b.png" width="1238" height="512" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-实现临界区进程互斥的软件实现方法">2. 实现临界区进程互斥的软件实现方法<a class="hash-link" href="#2-实现临界区进程互斥的软件实现方法" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="0-思维导图-1">0. 思维导图<a class="hash-link" href="#0-思维导图-1" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="进程互斥的软件实现方法" src="/assets/images/进程互斥的软件实现方法-73fd15b8a7fe5373a4dbdc43001ab037.png" width="1463" height="679" class="img_ev3q"></p><ul><li>软件实现方法的思想：在进入区设置并检查一些标志 来标明是否有进程在临界区中,若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。<strong>入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志</strong>。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-单标志法">1. 单标志法<a class="hash-link" href="#1-单标志法" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="单标志法1" src="/assets/images/单标志法1-4f92d07883cc2b05626ab297dc340ab7.png" width="1440" height="715" class="img_ev3q">
<img loading="lazy" alt="单标志法2" src="/assets/images/单标志法2-bd2609200735d42937a5e181d7b274e9.png" width="1398" height="227" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-双标志先检查法">2. 双标志先检查法<a class="hash-link" href="#2-双标志先检查法" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="双标志先检查法" src="/assets/images/双标志先检查法-6e4ebc2a7d87c90b8be7dd5881a335d6.png" width="1612" height="707" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-双标志后检查法">3. 双标志后检查法<a class="hash-link" href="#3-双标志后检查法" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="双标志后检查法" src="/assets/images/双标志后检查法-5074110bcc0e3a08143178a0faa38e28.png" width="1460" height="707" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4-peterson算法">4. Peterson算法<a class="hash-link" href="#4-peterson算法" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="Peterson算法1" src="/assets/images/Peterson算法1-bea64a32cb79b26ea2657b0e9231ed38.png" width="1468" height="730" class="img_ev3q">
<img loading="lazy" alt="Peterson算法2" src="/assets/images/Peterson算法2-d438ec8d2eb05d8669adcd3d4f20c629.png" width="1447" height="731" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3-实现临界区进程互斥的硬件实现方法">3. 实现临界区进程互斥的硬件实现方法<a class="hash-link" href="#3-实现临界区进程互斥的硬件实现方法" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="0-思维导图-2">0. 思维导图<a class="hash-link" href="#0-思维导图-2" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="进程互斥的硬件实现方法" src="/assets/images/进程互斥的硬件实现方法-392643a81b586e0dae80218f954774f5.png" width="1506" height="671" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-中断隐藏方法">1. 中断隐藏方法<a class="hash-link" href="#1-中断隐藏方法" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="中断隐藏方法" src="/assets/images/中断隐藏方法-713689897333e1c80c92723836dfcc6e.png" width="1416" height="610" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-testandset指令">2. TestAndSet指令<a class="hash-link" href="#2-testandset指令" title="Direct link to heading">​</a></h3><ul><li>执行TSL指令时，它的内部运转逻辑：</li><li>假设lock现在为false，代表临界资源A空闲，那么我就可以访问这个资源，同时将lock=true，提醒别的进程，这个临界资源A我正在使用，让他们等等</li><li>假设lock为true，代表临界资源正在有人使用，所以我必须等待，并且将lock=true，并不影响什么，所以没关系，只是为了让lock为false时可以上锁，将上锁与检查在一个TSL指令完成。</li></ul><p><img loading="lazy" alt="TestAndSet指令" src="/assets/images/TestAndSet指令-f4650b64a6ebe84643a50d39b375fe58.png" width="1528" height="746" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-swap指令">3. Swap指令<a class="hash-link" href="#3-swap指令" title="Direct link to heading">​</a></h3><ul><li>old是每个进程都要进行的一步，都必须将old=true</li><li>分析一下这样做的原因：</li><li>因为lock是某一特定临界资源的共享变量，当每一个进程准备访问这个特定的临界资源时，初始化old=true，然后进入while循环进行交换，如果当前lock是false,则交换后old=false,则当前进程可以跳出循环进入临界区代码段，同时因为交换，lock=old=true上锁，不让别的进程来打扰，别的进程会因为lock变为true,一直在while循环等待,当我使用完临界资源，则将lock=false,此时别的进程再交换old和lock就能判断old=false,可以跳出循环，使用临界资源。</li></ul><p><img loading="lazy" alt="Swap指令" src="/assets/images/Swap指令-82657560dc063bfdfb9836178213eebb.png" width="1428" height="699" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4-信号量机制整型信号量记录型信号量pv">4. 信号量机制（整型信号量、记录型信号量P、V）<a class="hash-link" href="#4-信号量机制整型信号量记录型信号量pv" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="0-思维导图-3">0. 思维导图<a class="hash-link" href="#0-思维导图-3" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="信号量机制" src="/assets/images/信号量机制-ca40890611f5dccf3301a2f71fb42023.png" width="1557" height="625" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-为什么引入信号量机制">1. 为什么引入信号量机制？<a class="hash-link" href="#1-为什么引入信号量机制" title="Direct link to heading">​</a></h3><ul><li>为了更好的解决进程互斥与同步的问题</li></ul><p><img loading="lazy" alt="为什么引入信号量机制" src="/assets/images/为什么引入信号量机制-e44154e150dd1d9b2ae49eed7cac9695.png" width="1529" height="714" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-什么是信号量机制">2. 什么是信号量机制？<a class="hash-link" href="#2-什么是信号量机制" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="什么是信号量机制" src="/assets/images/什么是信号量机制-5e40537c118647a39cf116e4002f960b.png" width="1491" height="591" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-整型信号量">3. 整型信号量<a class="hash-link" href="#3-整型信号量" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="整型信号量" src="/assets/images/整型信号量-03616f4cd2212e18a6292e7c3035a4c7.png" width="1499" height="820" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4-记录型信号量">4. 记录型信号量<a class="hash-link" href="#4-记录型信号量" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="记录型信号量" src="/assets/images/记录型信号量-1d3221a0583c59c8ef78430bdc1de075.png" width="1508" height="733" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1举一个生动形象的例子了解记录型信号量">（1）举一个生动形象的例子了解记录型信号量<a class="hash-link" href="#1举一个生动形象的例子了解记录型信号量" title="Direct link to heading">​</a></h4><ul><li>一张图咱们回忆一下进程的状态</li></ul><p><img loading="lazy" alt="进程的状态" src="/assets/images/进程的状态-bbebe51b593819a4f655eab26daa445f.png" width="972" height="604" class="img_ev3q"></p><ul><li>一个例子</li></ul><p><img loading="lazy" alt="记录型信号量例子1" src="/assets/images/记录型信号量例子1-cf02922c8c0d3cae8f4c14a87deb51c3.png" width="1535" height="720" class="img_ev3q">
<img loading="lazy" alt="记录型信号量例子2" src="/assets/images/记录型信号量例子2-2a45581ffe0ef01ce2f9ba498303d754.png" width="1534" height="754" class="img_ev3q">
<img loading="lazy" alt="记录型信号量例子3" src="/assets/images/记录型信号量例子3-f274b08b7498fc97754b34974200b7f7.png" width="1476" height="751" class="img_ev3q">
<img loading="lazy" alt="记录型信号量例子4" src="/assets/images/记录型信号量例子4-a71e2d38978ff6cea8d177b2cf9d7c8e.png" width="1483" height="753" class="img_ev3q">
<img loading="lazy" alt="记录型信号量例子5" src="/assets/images/记录型信号量例子5-975217608fdb5128d8673671c43157b9.png" width="1512" height="664" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="2梳理一下记录型信号量的知识点pv">（2）梳理一下记录型信号量的知识点（P、V）<a class="hash-link" href="#2梳理一下记录型信号量的知识点pv" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="记录型信号量的知识点" src="/assets/images/记录型信号量的知识点-ba4146ff052eee9da3cf48ac008455f8.png" width="1478" height="751" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="5-信号量机制实现进程的互斥同步与前驱关系">5. 信号量机制实现进程的互斥、同步与前驱关系<a class="hash-link" href="#5-信号量机制实现进程的互斥同步与前驱关系" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="0-思维导图-4">0. 思维导图<a class="hash-link" href="#0-思维导图-4" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="信号量机制2" src="/assets/images/信号量机制2-b5ef9debd8a24f45ed3957369af69b2e.png" width="1544" height="723" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-信号量机制实现进程互斥">1. 信号量机制实现进程互斥<a class="hash-link" href="#1-信号量机制实现进程互斥" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="信号量机制实现进程互斥" src="/assets/images/信号量机制实现进程互斥-41b513559358a075a70d4ced0c17b486.png" width="1511" height="718" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-信号量机制实现进程同步">2. 信号量机制实现进程同步<a class="hash-link" href="#2-信号量机制实现进程同步" title="Direct link to heading">​</a></h3><ul><li>想象一下四则运算的顺序，加减乘除；</li></ul><p><img loading="lazy" alt="信号量机制实现进程同步1" src="/assets/images/信号量机制实现进程同步1-d922df6c61b738910bcb1cdc13bbcf65.png" width="1457" height="613" class="img_ev3q"></p><ul><li>要想理解这一部分知识，必须知道P、V操作的内部实现原理</li></ul><p><img loading="lazy" alt="信号量机制实现进程同步2" src="/assets/images/信号量机制实现进程同步2-9f5edd646819b746d34661087a975f36.png" width="1508" height="727" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-信号量机制实现前驱关系">3. 信号量机制实现前驱关系<a class="hash-link" href="#3-信号量机制实现前驱关系" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="信号量机制实现前驱关系" src="/assets/images/信号量机制实现前驱关系-defe64c2169365410e9878064d515d15.png" width="1547" height="719" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="6-进程同步与互斥经典问题生产者-消费者问题多生产者-多消费者问题吸烟者问题读者-写者问题哲学家进餐问题">6. 进程同步与互斥经典问题（生产者-消费者问题、多生产者-多消费者问题、吸烟者问题、读者-写者问题、哲学家进餐问题）<a class="hash-link" href="#6-进程同步与互斥经典问题生产者-消费者问题多生产者-多消费者问题吸烟者问题读者-写者问题哲学家进餐问题" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="0-前言">0. 前言<a class="hash-link" href="#0-前言" title="Direct link to heading">​</a></h3><ul><li>同步时，前V后P。
<img loading="lazy" alt="前言" src="/assets/images/前言-f60785ec8f369c62a256d51492981e77.png" width="1441" height="286" class="img_ev3q"></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-生产者-消费者问题">1. 生产者-消费者问题<a class="hash-link" href="#1-生产者-消费者问题" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1问题描述">（1）问题描述<a class="hash-link" href="#1问题描述" title="Direct link to heading">​</a></h4><ul><li><p>系统中有<strong>一组生产者进程</strong>和<strong>一组消费者进程</strong>，生产者进程每次<strong>生产一个</strong>产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。(注: 这里的“产品”理解为某种数据)</p></li><li><p>生产者、消费者<strong>共享</strong>一个初始为空、大小为n的<strong>缓冲区</strong>。</p></li><li><p>只有缓冲区<strong>没满</strong>时，<strong>生产者</strong>才能把产品<strong>放入</strong>缓冲区，否则必须等待。</p></li><li><p>只有缓冲区<strong>不空</strong>时，<strong>消费者</strong>才能从中<strong>取出</strong>产品，否则必须等待。</p></li><li><p>缓冲区是临界资源，各进程必须<strong>互斥</strong>地访问。</p><p><img loading="lazy" alt="缓冲区问题" src="/assets/images/缓冲区问题-9ecb3c27937f39c3dbed98ea98b821b4.png" width="1346" height="434" class="img_ev3q"></p></li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="2问题分析">（2）问题分析<a class="hash-link" href="#2问题分析" title="Direct link to heading">​</a></h4><ul><li>1)关系分析。生产者和消费者对缓冲区互斥访问是<strong>互斥关系</strong>，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后,消费者才能消费，它们也是<strong>同步关系</strong>。</li><li>2)整理思路。根据各进程的操作流程确定P、V操作的大致顺序。<ul><li>生产者每次要消耗(P）一个空闲缓冲区，并生产(V)一个产品。</li><li>消费者每次要消耗(P）一个产品，并释放一个空闲缓冲区(V)。</li><li>往缓冲区放入/取走产品需要互斥。</li></ul></li><li>3)信号量设置。设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。( 互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)</li></ul><p><img loading="lazy" alt="问题分析" src="/assets/images/问题分析-86ddeba9a889ded39535ad41fc8dd9cf.png" width="1364" height="136" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="3如何实现">（3）如何实现？<a class="hash-link" href="#3如何实现" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="如何实现" src="/assets/images/如何实现-bf845b103ab70623e585aece00ae15a7.png" width="1599" height="719" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="4实现互斥的p操作一定要在实现同步的p操作之后">（4）实现互斥的P操作一定要在实现同步的P操作之后<a class="hash-link" href="#4实现互斥的p操作一定要在实现同步的p操作之后" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="实现互斥的P操作一定要在实现同步的P操作之后" src="/assets/images/实现互斥的P操作一定要在实现同步的P操作之后-56efcc4252a9efd2801028d306523d24.png" width="1531" height="734" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="5知识回顾与重要考点">（5）知识回顾与重要考点<a class="hash-link" href="#5知识回顾与重要考点" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="知识回顾与重要考点" src="/assets/images/知识回顾与重要考点-6dea40f5d3e71e500ce9fb2b40be024e.png" width="1424" height="715" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2多生产者-多消费者问题">2.多生产者-多消费者问题<a class="hash-link" href="#2多生产者-多消费者问题" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1问题描述-1">（1）问题描述<a class="hash-link" href="#1问题描述-1" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="问题描述" src="/assets/images/问题描述-df4a00735601b6e93628d1e028f64ff6.png" width="1543" height="719" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="2问题分析-1">（2）问题分析<a class="hash-link" href="#2问题分析-1" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="问题分析1" src="/assets/images/问题分析1-d5d1955b636af85b1c7833ef958c4c82.png" width="1503" height="711" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="3实现方法">（3）实现方法<a class="hash-link" href="#3实现方法" title="Direct link to heading">​</a></h4><h5 class="anchor anchorWithStickyNavbar_LWe7" id="-有mutex">① 有mutex<a class="hash-link" href="#-有mutex" title="Direct link to heading">​</a></h5><p><img loading="lazy" alt="有mutex" src="/assets/images/有mutex-79f2c82dd5c5516dbdfed33f0b4e3513.png" width="1565" height="800" class="img_ev3q"></p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="-无mutex">② 无mutex<a class="hash-link" href="#-无mutex" title="Direct link to heading">​</a></h5><p><img loading="lazy" alt="无mutex" src="/assets/images/无mutex-8662b53b421027f85ee26855de696997.png" width="1569" height="844" class="img_ev3q"></p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="-为什么有mutex和没有mutex一样呢">③ 为什么有mutex和没有mutex一样呢？<a class="hash-link" href="#-为什么有mutex和没有mutex一样呢" title="Direct link to heading">​</a></h5><ul><li>原因在于:本题中的缓冲区大小为1，在任何时刻，apple、 orange、 plate 三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…</li></ul><h5 class="anchor anchorWithStickyNavbar_LWe7" id="-如果有两个盘子plate">④ 如果有两个盘子plate<a class="hash-link" href="#-如果有两个盘子plate" title="Direct link to heading">​</a></h5><p><img loading="lazy" alt="如果有两个盘子plate" src="/assets/images/如果有两个盘子plate-73364a1afd2025fa880a88d588215a51.png" width="1566" height="836" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="4知识总结与重要考点">（4）知识总结与重要考点<a class="hash-link" href="#4知识总结与重要考点" title="Direct link to heading">​</a></h4><ul><li>总结:在生产者_消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，<strong>这不是绝对的</strong>，要具体问题具体分析。</li><li>建议:在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，<strong>·实现互斥的P操作一定要在实现同步的P操作之后·</strong>，否则可能引起·<strong>“死锁”</strong>·。</li></ul><p><img loading="lazy" alt="知识总结与重要考点" src="/assets/images/知识总结与重要考点-bdc866c8d0c1214dce9b2b3f68b4ac14.png" width="1497" height="733" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-读者-写者问题">3. 读者-写者问题<a class="hash-link" href="#3-读者-写者问题" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1问题描述-2">（1）问题描述<a class="hash-link" href="#1问题描述-2" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="问题描述1" src="/assets/images/问题描述1-b2c0ddac6a8304716fec92368a55e7c1.png" width="1449" height="722" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="2问题分析-2">（2）问题分析<a class="hash-link" href="#2问题分析-2" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="问题分析2" src="/assets/images/问题分析2-ea3fca3d7135a48865df9bf64b01f349.png" width="1458" height="708" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="3实现方法-1">（3）实现方法<a class="hash-link" href="#3实现方法-1" title="Direct link to heading">​</a></h4><h5 class="anchor anchorWithStickyNavbar_LWe7" id="-给count加mutex互斥访问">① 给count加mutex互斥访问<a class="hash-link" href="#-给count加mutex互斥访问" title="Direct link to heading">​</a></h5><ul><li>这里说一下为什么要加mutex。</li><li>比如：当count=0时，第一个读者进程执行到p(rw),rw=0,假设此时时间片到了，切换到第二个读者进程,第二个进程发现count=0,则执行p(rw)，但是此时rw=0，于是第二个进程被堵在p（rw）这里，同理，后面的可能会有多个进程堵在p(rw)，只有当第一个进程再次获得时间片，执行count++,让count不为0，然后其他进程就可以直接绕过if直接进行count++来访问文件，但是第三个读者进程和后面的几个可能堵在p(rw)的多个读者进程则必须得等count–为0后才可以再次和写进程竞争来访问文件，对count的访问没有做到一气呵成，会导致本来一些进程一直堵在p（rw）。</li></ul><p><img loading="lazy" alt="给count加mutex互斥访问" src="/assets/images/给count加mutex互斥访问-a50e3ba1975de9f57665cfe52e562b40.png" width="1551" height="732" class="img_ev3q"></p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="-加一个w实现读写公平法">② 加一个w实现“读写公平法”<a class="hash-link" href="#-加一个w实现读写公平法" title="Direct link to heading">​</a></h5><ul><li>在上面的算法中，读进程是优先的，即当存在读进程时，写操作将被延迟，且只要有 一个读进程活跃，随后而来的读进程都将被允许访问文件。这样的方式会导致写进程可能长时间等待，且存在写进程“饿死”的情况。</li><li>若希望写进程优先，即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等到已在共享文件的读进程执行完毕，立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行。为此，增加一个信号量并在上面程序的writer()和 reader()函数中各增加一对PV操作，就可以得到写进程优先的解决程序。</li></ul><p><img loading="lazy" alt="加一个w实现“读写公平法”" src="/assets/images/加一个w实现“读写公平法”-ffa564fc7141060ff1b9ebf457abaac4.png" width="1541" height="685" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="4知识回顾与重要考点">（4）知识回顾与重要考点<a class="hash-link" href="#4知识回顾与重要考点" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="知识回顾与重要考点1" src="/assets/images/知识回顾与重要考点1-daabd6c65d79f2c131e78f8a4a3e9ada.png" width="1443" height="376" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4-吸烟者问题">4. 吸烟者问题<a class="hash-link" href="#4-吸烟者问题" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1问题描述-3">（1）问题描述<a class="hash-link" href="#1问题描述-3" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="吸烟者问题描述" src="/assets/images/吸烟者问题描述-ce78f58bb1f4999a03b35f8d9e5debc2.png" width="1361" height="722" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="2问题分析-3">（2）问题分析<a class="hash-link" href="#2问题分析-3" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="吸烟者问题分析" src="/assets/images/吸烟者问题分析-1b28b8a92b12b8baa4acab0121c6e3e5.png" width="1376" height="718" class="img_ev3q">
<img loading="lazy" alt="吸烟者问题分析1" src="/assets/images/吸烟者问题分析1-13e99c39bb287efadb7ed3014bbd9bee.png" width="1432" height="552" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="3实现方法-2">（3）实现方法<a class="hash-link" href="#3实现方法-2" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="吸烟者问题实现方法" src="/assets/images/吸烟者问题实现方法-539c910a2be49603a4cdcb6424fc44f8.png" width="1605" height="856" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="4知识回顾与重要考点-1">（4）知识回顾与重要考点<a class="hash-link" href="#4知识回顾与重要考点-1" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="吸烟者问题总结" src="/assets/images/吸烟者问题总结-18c13b6e432cfe1fda5a759d4c179c22.png" width="1397" height="345" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5-哲学家进餐问题">5. 哲学家进餐问题<a class="hash-link" href="#5-哲学家进餐问题" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1问题描述-4">（1）问题描述<a class="hash-link" href="#1问题描述-4" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="哲学家进餐问题描述" src="/assets/images/哲学家进餐问题描述-26f4d1a35d4f94db37ac0c29cb15cc62.png" width="1492" height="752" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="2问题分析-4">（2）问题分析<a class="hash-link" href="#2问题分析-4" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="哲学家进餐问题分析" src="/assets/images/哲学家进餐问题分析-9213e484943ce987da08fddbcbb89123.png" width="1476" height="763" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="3如何实现-1">（3）如何实现<a class="hash-link" href="#3如何实现-1" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="哲学家进餐问题实现1" src="/assets/images/哲学家进餐问题实现1-067635a1cfa86521d94d293f8223371a.png" width="1525" height="733" class="img_ev3q">
<img loading="lazy" alt="哲学家进餐问题实现2" src="/assets/images/哲学家进餐问题实现2-c0f816ddbf9538d9de090d569022f604.png" width="1493" height="745" class="img_ev3q">
<img loading="lazy" alt="哲学家进餐问题实现3" src="/assets/images/哲学家进餐问题实现3-88a5a2b5dd8b26c1e5f1ddc6b0c81fad.png" width="1565" height="856" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="4知识回顾与重要考点-2">（4）知识回顾与重要考点<a class="hash-link" href="#4知识回顾与重要考点-2" title="Direct link to heading">​</a></h4><p><img loading="lazy" alt="哲学家进餐问题回顾" src="/assets/images/哲学家进餐问题回顾-0332df5fb29e3c5e61b6590fe4fb1e97.png" width="1380" height="289" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="7-管程和java中实现管程的机制">7. 管程和java中实现管程的机制<a class="hash-link" href="#7-管程和java中实现管程的机制" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="0-思维导图-5">0. 思维导图<a class="hash-link" href="#0-思维导图-5" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="管程" src="/assets/images/管程-963c5c88e4f5d11f683e81637a5c9397.png" width="723" height="328" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-为什么引入管程">1. 为什么引入管程？<a class="hash-link" href="#1-为什么引入管程" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="为什么引入管程" src="/assets/images/为什么引入管程-c9d36ea4c8d855460cbbe5c9291582fa.png" width="1443" height="720" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-管程的组成及基本特征">2. 管程的组成及基本特征<a class="hash-link" href="#2-管程的组成及基本特征" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="管程的组成及基本特征" src="/assets/images/管程的组成及基本特征-bfd324f09b5db7f64b5800b6f492fe13.png" width="1286" height="502" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-管程实现生产者消费者问题">3. 管程实现生产者消费者问题<a class="hash-link" href="#3-管程实现生产者消费者问题" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="管程实现生产者消费者问题1" src="/assets/images/管程实现生产者消费者问题1-3c515de84b8e7c9046f6650f6508e3ae.png" width="1449" height="702" class="img_ev3q">
<img loading="lazy" alt="管程实现生产者消费者问题2" src="/assets/images/管程实现生产者消费者问题2-09245dd011a2bf572aef6f57fd1c5a9b.png" width="1487" height="697" class="img_ev3q">
<img loading="lazy" alt="管程实现生产者消费者问题3" src="/assets/images/管程实现生产者消费者问题3-1cbe38a0c1bf4999dbd22d53f05b6c52.png" width="1437" height="701" class="img_ev3q">
<img loading="lazy" alt="管程实现生产者消费者问题4" src="/assets/images/管程实现生产者消费者问题4-f1cfc64585921d845ecf357f00d9135d.png" width="1427" height="707" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4-java中类似于管程的机制">4. java中类似于管程的机制<a class="hash-link" href="#4-java中类似于管程的机制" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="java中类似于管程的机制" src="/assets/images/java中类似于管程的机制-c8910de18c1ddab7360bedffaa0e8ae5.png" width="1415" height="648" class="img_ev3q"></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/operating-system/进程的同步与互斥.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/operating-system/处理机的调度"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">2. 处理机的调度</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/operating-system/死锁"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">4. 死锁</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-进程的同步与互斥" class="table-of-contents__link toc-highlight">1. 进程的同步与互斥</a><ul><li><a href="#0-思维导图" class="table-of-contents__link toc-highlight">0. 思维导图</a></li><li><a href="#1-进程同步" class="table-of-contents__link toc-highlight">1. 进程同步</a></li><li><a href="#2-进程互斥" class="table-of-contents__link toc-highlight">2. 进程互斥</a></li></ul></li><li><a href="#2-实现临界区进程互斥的软件实现方法" class="table-of-contents__link toc-highlight">2. 实现临界区进程互斥的软件实现方法</a><ul><li><a href="#0-思维导图-1" class="table-of-contents__link toc-highlight">0. 思维导图</a></li><li><a href="#1-单标志法" class="table-of-contents__link toc-highlight">1. 单标志法</a></li><li><a href="#2-双标志先检查法" class="table-of-contents__link toc-highlight">2. 双标志先检查法</a></li><li><a href="#3-双标志后检查法" class="table-of-contents__link toc-highlight">3. 双标志后检查法</a></li><li><a href="#4-peterson算法" class="table-of-contents__link toc-highlight">4. Peterson算法</a></li></ul></li><li><a href="#3-实现临界区进程互斥的硬件实现方法" class="table-of-contents__link toc-highlight">3. 实现临界区进程互斥的硬件实现方法</a><ul><li><a href="#0-思维导图-2" class="table-of-contents__link toc-highlight">0. 思维导图</a></li><li><a href="#1-中断隐藏方法" class="table-of-contents__link toc-highlight">1. 中断隐藏方法</a></li><li><a href="#2-testandset指令" class="table-of-contents__link toc-highlight">2. TestAndSet指令</a></li><li><a href="#3-swap指令" class="table-of-contents__link toc-highlight">3. Swap指令</a></li></ul></li><li><a href="#4-信号量机制整型信号量记录型信号量pv" class="table-of-contents__link toc-highlight">4. 信号量机制（整型信号量、记录型信号量P、V）</a><ul><li><a href="#0-思维导图-3" class="table-of-contents__link toc-highlight">0. 思维导图</a></li><li><a href="#1-为什么引入信号量机制" class="table-of-contents__link toc-highlight">1. 为什么引入信号量机制？</a></li><li><a href="#2-什么是信号量机制" class="table-of-contents__link toc-highlight">2. 什么是信号量机制？</a></li><li><a href="#3-整型信号量" class="table-of-contents__link toc-highlight">3. 整型信号量</a></li><li><a href="#4-记录型信号量" class="table-of-contents__link toc-highlight">4. 记录型信号量</a><ul><li><a href="#1举一个生动形象的例子了解记录型信号量" class="table-of-contents__link toc-highlight">（1）举一个生动形象的例子了解记录型信号量</a></li><li><a href="#2梳理一下记录型信号量的知识点pv" class="table-of-contents__link toc-highlight">（2）梳理一下记录型信号量的知识点（P、V）</a></li></ul></li></ul></li><li><a href="#5-信号量机制实现进程的互斥同步与前驱关系" class="table-of-contents__link toc-highlight">5. 信号量机制实现进程的互斥、同步与前驱关系</a><ul><li><a href="#0-思维导图-4" class="table-of-contents__link toc-highlight">0. 思维导图</a></li><li><a href="#1-信号量机制实现进程互斥" class="table-of-contents__link toc-highlight">1. 信号量机制实现进程互斥</a></li><li><a href="#2-信号量机制实现进程同步" class="table-of-contents__link toc-highlight">2. 信号量机制实现进程同步</a></li><li><a href="#3-信号量机制实现前驱关系" class="table-of-contents__link toc-highlight">3. 信号量机制实现前驱关系</a></li></ul></li><li><a href="#6-进程同步与互斥经典问题生产者-消费者问题多生产者-多消费者问题吸烟者问题读者-写者问题哲学家进餐问题" class="table-of-contents__link toc-highlight">6. 进程同步与互斥经典问题（生产者-消费者问题、多生产者-多消费者问题、吸烟者问题、读者-写者问题、哲学家进餐问题）</a><ul><li><a href="#0-前言" class="table-of-contents__link toc-highlight">0. 前言</a></li><li><a href="#1-生产者-消费者问题" class="table-of-contents__link toc-highlight">1. 生产者-消费者问题</a><ul><li><a href="#1问题描述" class="table-of-contents__link toc-highlight">（1）问题描述</a></li><li><a href="#2问题分析" class="table-of-contents__link toc-highlight">（2）问题分析</a></li><li><a href="#3如何实现" class="table-of-contents__link toc-highlight">（3）如何实现？</a></li><li><a href="#4实现互斥的p操作一定要在实现同步的p操作之后" class="table-of-contents__link toc-highlight">（4）实现互斥的P操作一定要在实现同步的P操作之后</a></li><li><a href="#5知识回顾与重要考点" class="table-of-contents__link toc-highlight">（5）知识回顾与重要考点</a></li></ul></li><li><a href="#2多生产者-多消费者问题" class="table-of-contents__link toc-highlight">2.多生产者-多消费者问题</a><ul><li><a href="#1问题描述-1" class="table-of-contents__link toc-highlight">（1）问题描述</a></li><li><a href="#2问题分析-1" class="table-of-contents__link toc-highlight">（2）问题分析</a></li><li><a href="#3实现方法" class="table-of-contents__link toc-highlight">（3）实现方法</a><ul><li><a href="#-有mutex" class="table-of-contents__link toc-highlight">① 有mutex</a></li><li><a href="#-无mutex" class="table-of-contents__link toc-highlight">② 无mutex</a></li><li><a href="#-为什么有mutex和没有mutex一样呢" class="table-of-contents__link toc-highlight">③ 为什么有mutex和没有mutex一样呢？</a></li><li><a href="#-如果有两个盘子plate" class="table-of-contents__link toc-highlight">④ 如果有两个盘子plate</a></li></ul></li><li><a href="#4知识总结与重要考点" class="table-of-contents__link toc-highlight">（4）知识总结与重要考点</a></li></ul></li><li><a href="#3-读者-写者问题" class="table-of-contents__link toc-highlight">3. 读者-写者问题</a><ul><li><a href="#1问题描述-2" class="table-of-contents__link toc-highlight">（1）问题描述</a></li><li><a href="#2问题分析-2" class="table-of-contents__link toc-highlight">（2）问题分析</a></li><li><a href="#3实现方法-1" class="table-of-contents__link toc-highlight">（3）实现方法</a><ul><li><a href="#-给count加mutex互斥访问" class="table-of-contents__link toc-highlight">① 给count加mutex互斥访问</a></li><li><a href="#-加一个w实现读写公平法" class="table-of-contents__link toc-highlight">② 加一个w实现“读写公平法”</a></li></ul></li><li><a href="#4知识回顾与重要考点" class="table-of-contents__link toc-highlight">（4）知识回顾与重要考点</a></li></ul></li><li><a href="#4-吸烟者问题" class="table-of-contents__link toc-highlight">4. 吸烟者问题</a><ul><li><a href="#1问题描述-3" class="table-of-contents__link toc-highlight">（1）问题描述</a></li><li><a href="#2问题分析-3" class="table-of-contents__link toc-highlight">（2）问题分析</a></li><li><a href="#3实现方法-2" class="table-of-contents__link toc-highlight">（3）实现方法</a></li><li><a href="#4知识回顾与重要考点-1" class="table-of-contents__link toc-highlight">（4）知识回顾与重要考点</a></li></ul></li><li><a href="#5-哲学家进餐问题" class="table-of-contents__link toc-highlight">5. 哲学家进餐问题</a><ul><li><a href="#1问题描述-4" class="table-of-contents__link toc-highlight">（1）问题描述</a></li><li><a href="#2问题分析-4" class="table-of-contents__link toc-highlight">（2）问题分析</a></li><li><a href="#3如何实现-1" class="table-of-contents__link toc-highlight">（3）如何实现</a></li><li><a href="#4知识回顾与重要考点-2" class="table-of-contents__link toc-highlight">（4）知识回顾与重要考点</a></li></ul></li></ul></li><li><a href="#7-管程和java中实现管程的机制" class="table-of-contents__link toc-highlight">7. 管程和java中实现管程的机制</a><ul><li><a href="#0-思维导图-5" class="table-of-contents__link toc-highlight">0. 思维导图</a></li><li><a href="#1-为什么引入管程" class="table-of-contents__link toc-highlight">1. 为什么引入管程？</a></li><li><a href="#2-管程的组成及基本特征" class="table-of-contents__link toc-highlight">2. 管程的组成及基本特征</a></li><li><a href="#3-管程实现生产者消费者问题" class="table-of-contents__link toc-highlight">3. 管程实现生产者消费者问题</a></li><li><a href="#4-java中类似于管程的机制" class="table-of-contents__link toc-highlight">4. java中类似于管程的机制</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">计算机</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/operating-system/操作系统的基本概念">数据结构</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/operating-system/操作系统的基本概念">操作系统</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/network/计算机网络-1.概述">计算机网络</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/The-End-Hero/xiping-work-docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 xiping.wang, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.61241a0c.js"></script>
<script src="/assets/js/main.01c9ea38.js"></script>
</body>
</html>